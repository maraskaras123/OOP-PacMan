@page "/session/{SessionId}"
@using Microsoft.AspNetCore.SignalR.Client
@inject NavigationManager Navigation
@implements IAsyncDisposable
@using PacMan.Client.Classes;
@using PacMan.Shared.Models;
@using PacMan.Shared.Enums;
@using PacMan.Client.Services;
@using System.Drawing

<PageTitle>Game test</PageTitle>

<style>
    /* Define a CSS class to style the table cells */
    .grid-cell {
        /* border: 1px solid #000; */
        /* Add border styles as needed */
        width: 30px;
        /* Adjust cell width as needed */
        height: 30px;
        /* Adjust cell height as needed */
    }

    .wall {
        background-color: cornflowerblue;
    }

    .pellet {
        border-radius: 50%;
        background-color: white;
        height: 10px;
        width: 10px;
        display: flex;
        align-items: center;
    }

    .game-grid {
        border: 1px solid #000;
        background-color: #000;
    }

    .scoreboard {
        border: 2px solid #000;
        width: 500px;
        display: flex;
        flex-direction: column;
        padding-top: 15px;
        padding-left: 15px;
    }
</style>


@if (_gameState == EnumGameState.Initializing)
{
    <h5>Choose your name:</h5>
    <InputText @bind-Value="PlayerName"></InputText>
    <button @onclick="ChangeName" disabled="@(!IsConnected)">Change</button>
    <br/>
    @if (_players.FirstOrDefault()?.Name == PlayerName)
    {
        <label>width</label>
        <input @bind="_gridOptions.Width"/>
        <label>height</label>
        <input @bind="_gridOptions.Height"/>
        <label>random tiles</label>
        <input @bind="_gridOptions.RandomTileCount"/>
    }

    <h5>Choose your input method:</h5>
    <input type="radio" id="keyboard" name="inputMethod" value="Keyboard"
           @onchange="() => ChangeInputMethod(EnumInputMethod.Keyboard)" checked="@IsKeyboardSelected"/>
    <label for="keyboard">Keyboard</label>
    <br/>
    <input type="radio" id="buttons" name="inputMethod" value="Buttons"
           @onchange="() => ChangeInputMethod(EnumInputMethod.Buttons)" checked="@IsButtonsSelected"/>
    <label for="buttons">On-Screen Buttons</label>

    <br/>
    <table>
        <thead>
        <tr>
            <th>Name</th>
        </tr>
        </thead>
        <tbody>
        @foreach (var player in _players)
        {
            <tr>
                <td>@player.Name</td>
            </tr>
        }
        </tbody>
    </table>

    @if (_players.FirstOrDefault()?.Name == PlayerName)
    {
        <br />
        <button @onclick="Start" disabled="@(!IsConnected)">Start</button>
    }
}

@if (_gameState == EnumGameState.Starting)
{
    <p>Game is starting...</p>
}

@if (_gameState == EnumGameState.Finished)
{
    <p>Finished!!</p>
    <button @onclick="async () => await Restart()">Restart</button>
}

@if (_gameState == EnumGameState.Running)
{
    @if (_selectedInputMethod == EnumInputMethod.Keyboard)
    {
        <script>
            document.addEventListener('keydown', event => {
                DotNet.invokeMethodAsync('PacMan.Client', 'HandleKeyboardInput', event.key);
            });
        </script>
    }
    <div class="scoreboard">
        @foreach (var playerScore in _points)
        {
            <p>@(new MarkupString(GetPacmanColorByPlayer(playerScore.PlayerId))) Player @(playerScore.PlayerId + 1): @playerScore.Points points</p>
        }
    </div>
    <br/>

    <table class="game-grid">
        @for (var i = 0; i < _grid.Height; i++)
        {
            <tr>
                @for (var j = 0; j < _grid.Width; j++)
                {
                    // get current positions enemy, player and tile
                    var enemyAtPosition = _enemies.FirstOrDefault(e => e.Position == new Point(j, i));
                    var playerAtPosition = "";
                    foreach (var coordinates in _playerCoordinates.Select(x => x.Split(',')))
                    {
                        if (int.Parse(coordinates[1]) == j && int.Parse(coordinates[2]) == i)
                        {
                            playerAtPosition = coordinates[0];
                        }
                    }
                    var tileType = _grid.GetTile(j, i);

                    // if player at current position - render player
                    if (playerAtPosition != "")
                    {
                        <td class="grid-cell">
                            <center>
                                @(new MarkupString(GetPacmanColorByPlayer(int.Parse(playerAtPosition))))
                            </center>
                        </td>
                    }
                    else
                    // no player at current position - render enemy
                        if (enemyAtPosition != null)
                        {
                            <td class="grid-cell">
                                <center>
                                    @(new MarkupString(GetGhostColorByChar(enemyAtPosition.Character)))
                                </center>
                            </td>
                        }
                        else
                        // no player or enemy at current position - render tile
                        {
                            switch (tileType)
                            {
                                case EnumTileType.Wall:
                                    @(new MarkupString("<td class='grid-cell wall'></td>"))
                                    break;
                                case EnumTileType.Pellet:
                                    @(new MarkupString("<td class='grid-cell'><center><div class='pellet'></center></div></td>"))
                                    break;
                                default:
                                    @(new MarkupString("<td class='grid-cell'></td>"))
                                    break;
                            }
                        }
                }
            </tr>
        }
    </table>

    @if (_selectedInputMethod == EnumInputMethod.Buttons)
    {
        <br/>
        <button @onclick="async () => _input.ChangeDirection(EnumDirection.Up.ToString())">↑</button>

        <br/>
        <button @onclick="async () => _input.ChangeDirection(EnumDirection.Left.ToString())">←</button>
        <button @onclick="async () => _input.ChangeDirection(EnumDirection.Right.ToString())">→</button>

        <br/>
        <button @onclick="async () => _input.ChangeDirection(EnumDirection.Down.ToString())">↓</button>
        <br/>
    }
}

@code {
    private EnumInputMethod _selectedInputMethod = EnumInputMethod.Keyboard;
    private bool IsKeyboardSelected => _selectedInputMethod == EnumInputMethod.Keyboard;
    private bool IsButtonsSelected => _selectedInputMethod == EnumInputMethod.Buttons;
    private bool IsConnected => _hubConnection?.State == HubConnectionState.Connected;

    private readonly TileGridBuilderOptions _gridOptions = new();
    private List<PlayerStateBaseModel> _players = new();
    private GridModel _grid = new();
    private List<EnemyModel> _enemies = new();
    private HubConnection? _hubConnection;
    private List<PlayerScore> _points = new();
    private List<string> _playerCoordinates = new();
    private EnumGameState? _gameState;
    private InputService _input;
    private string PlayerName { get; set; }

    [Parameter]
    public string SessionId { get; set; }

    protected override async Task OnInitializedAsync()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl($"{Program.ApiUrl}/gamehub")
            .Build();
        _hubConnection.On<List<PlayerStateBaseModel>>("Joined", OnJoined);
        _hubConnection.On<EnumGameState>("StateChange", OnStateChange);
        _hubConnection.On<GridModel>("ReceiveGrid", OnReceiveGrid);
        _hubConnection.On<List<EnemyModel>>("ReceiveEnemies", OnReceiveEnemies);
        _hubConnection.On<StateModel>("Tick", OnTick);
        PlayerName = $"Player {new Random().Next()}";
        SetInputMethod();

        try
        {
            await _hubConnection.StartAsync();
            await _hubConnection.InvokeAsync("JoinSession", SessionId, PlayerName);
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
        }
        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.DisposeAsync();
        }
    }

    #region HubListeners

    private async Task OnJoined(List<PlayerStateBaseModel> players)
    {
        Console.WriteLine($"Players: {players.Count}");
        _players = players;
        StateHasChanged();
    }

    private async Task OnStateChange(EnumGameState state)
    {
        _gameState = state;
        SetInputMethod();
        StateHasChanged();
    }

    private async Task OnReceiveGrid(GridModel receivedGrid)
    {
        _grid = receivedGrid;
        StateHasChanged();
    }

    private async Task OnReceiveEnemies(List<EnemyModel> receivedEnemies)
    {
        _enemies = receivedEnemies;
        StateHasChanged();
    }

    private async Task OnTick(StateModel model)
    {
        _gameState = model.GameState;

        _playerCoordinates = model.Coordinates;
        _points = new();
        for (var i = 0; i < model.Points.Count; i++)
        {
            _points.Add(new(i, model.Points[i]));
        }

        _points = _points.OrderByDescending(ps => ps.Points).ToList();
        StateHasChanged();
    }

    #endregion

    private void ChangeInputMethod(EnumInputMethod method)
    {
        _selectedInputMethod = method;
    }

    private void SetInputMethod()
    {
        _input = new(_selectedInputMethod, _hubConnection);
    }

    private void Start()
    {
        if (_hubConnection is not null)
        {
            var invoker = new Invoker();
            invoker.SetCommand(new StartCommand(_hubConnection, _gridOptions));
            invoker.InvokeCommand();
        }
        StateHasChanged();
    }

    private async Task Restart()
    {
        if (_hubConnection is not null)
        {
            if (_hubConnection.State == HubConnectionState.Disconnected)
            {
                await _hubConnection.StartAsync();
            }

            await _hubConnection.InvokeAsync("OnRestart");
        }
    }

    private async Task ChangeName()
    {
        if (_hubConnection is not null)
        {
            await _hubConnection.InvokeAsync("OnChangeName", PlayerName);
        }
    }

    private class PlayerScore
    {
        public int PlayerId { get; set; }
        public int Points { get; set; }

        public PlayerScore(int playerId, int points)
        {
            PlayerId = playerId;
            Points = points;
        }
    }
}

@functions {
    // these really should just be svg files not these dumb ass functions
    public string GetPacmanSvgString(string color = "eb343a")
    {
        return $"<svg height='18px' width='18px' version='1.1' id='Capa_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 52 52' xml:space='preserve'><g><path style='fill:#{color};' d='M44.385,44.385c-10.154,10.154-26.616,10.154-36.77,0s-10.154-26.616,0-36.77s26.616-10.154,36.77,0L26,26L44.385,44.385z'/></g></svg>";
    }

    public string GetGhostSvgString(string color = "2803ff")
    {
        return "<svg width=\"20px\" height=\"20px\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">" +
               $"<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M22 19.2058V12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12V19.2058C2 20.4896 3.35098 21.3245 4.4992 20.7504C5.42726 20.2864 6.5328 20.3552 7.39614 20.9308C8.36736 21.5782 9.63264 21.5782 10.6039 20.9308L10.9565 20.6957C11.5884 20.2744 12.4116 20.2744 13.0435 20.6957L13.3961 20.9308C14.3674 21.5782 15.6326 21.5782 16.6039 20.9308C17.4672 20.3552 18.5727 20.2864 19.5008 20.7504C20.649 21.3245 22 20.4896 22 19.2058ZM16 10.5C16 11.3284 15.5523 12 15 12C14.4477 12 14 11.3284 14 10.5C14 9.67157 14.4477 9 15 9C15.5523 9 16 9.67157 16 10.5ZM9 12C9.55228 12 10 11.3284 10 10.5C10 9.67157 9.55228 9 9 9C8.44772 9 8 9.67157 8 10.5C8 11.3284 8.44772 12 9 12Z\" fill=\"#{color}\" />" +
               "</svg>";
    }

    public string GetPacmanColorByPlayer(int player)
    {
        return player switch
        {
            0 => GetPacmanSvgString("F0C419"),
            1 => GetPacmanSvgString("34eb5e"),
            2 => GetPacmanSvgString("344feb"),
            _ => GetPacmanSvgString()
            };
    }

    public string GetGhostColorByChar(char character)
    {
        return character switch
        {
            'B' => GetGhostSvgString("2803ff"),
            'R' => GetGhostSvgString("ff0303"),
            _ => GetGhostSvgString()
            };
    }

}